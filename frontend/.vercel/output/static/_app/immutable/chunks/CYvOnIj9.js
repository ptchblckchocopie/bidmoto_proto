import{g as y}from"./BTM6jyxq.js";function b(){return""}const i=b();function a(){const e=y(),t={"Content-Type":"application/json"};return e&&(t.Authorization=`JWT ${e}`),t}async function q(e){try{const t=new URLSearchParams;e!=null&&e.page&&t.append("page",e.page.toString()),e!=null&&e.limit&&t.append("limit",e.limit.toString());let r=0;if((e==null?void 0:e.status)==="active"?(t.append(`where[and][${r}][status][equals]`,"available"),r++,t.append(`where[and][${r}][active][equals]`,"true"),r++):(e==null?void 0:e.status)==="ended"&&(t.append(`where[and][${r}][or][0][status][equals]`,"ended"),t.append(`where[and][${r}][or][1][status][equals]`,"sold"),r++),e!=null&&e.region&&e.region.trim()&&(t.append(`where[and][${r}][region][contains]`,e.region.trim()),r++),e!=null&&e.city&&e.city.trim()&&(t.append(`where[and][${r}][city][contains]`,e.city.trim()),r++),e!=null&&e.search&&e.search.trim()){const c=e.search.trim();t.append(`where[and][${r}][or][0][title][contains]`,c),t.append(`where[and][${r}][or][1][description][contains]`,c),t.append(`where[and][${r}][or][2][keywords.keyword][contains]`,c),t.append(`where[and][${r}][or][3][region][contains]`,c),t.append(`where[and][${r}][or][4][city][contains]`,c),r++}t.append("sort","-createdAt");const n=await((e==null?void 0:e.customFetch)||fetch)(`${i}/api/bridge/products?${t.toString()}`,{headers:a(),credentials:"include"});if(!n.ok)throw new Error("Failed to fetch products");const s=await n.json();return{docs:s.docs||[],totalDocs:s.totalDocs||0,totalPages:s.totalPages||0,page:s.page||1,limit:s.limit||10}}catch(t){return console.error("Error fetching products:",t),{docs:[],totalDocs:0,totalPages:0,page:1,limit:10}}}async function S(e){try{const t=await f(e==null?void 0:e.customFetch);if(!t)return{docs:[],totalDocs:0,totalPages:0,page:1,limit:(e==null?void 0:e.limit)||12};const r=new URLSearchParams;r.append("where[bidder][equals]",t.id),r.append("limit","1000");const o=(e==null?void 0:e.customFetch)||fetch,n=await o(`${i}/api/bridge/bids?${r.toString()}`,{headers:a(),credentials:"include"});if(!n.ok)throw new Error("Failed to fetch user bids");const c=(await n.json()).docs||[],d=new Set;if(c.forEach(l=>{const g=typeof l.product=="object"?l.product.id:l.product;d.add(g)}),d.size===0)return{docs:[],totalDocs:0,totalPages:0,page:(e==null?void 0:e.page)||1,limit:(e==null?void 0:e.limit)||12};const u=new URLSearchParams;if(Array.from(d).forEach((l,g)=>{u.append(`where[id][in][${g}]`,l)}),u.append("where[and][0][status][equals]","available"),u.append("where[and][1][active][equals]","true"),e!=null&&e.search&&e.search.trim()){const l=e.search.trim();u.append("where[and][2][or][0][title][contains]",l),u.append("where[and][2][or][1][description][contains]",l),u.append("where[and][2][or][2][keywords.keyword][contains]",l)}e!=null&&e.page&&u.append("page",e.page.toString()),e!=null&&e.limit&&u.append("limit",e.limit.toString()),u.append("sort","-createdAt");const w=await o(`${i}/api/bridge/products?${u.toString()}`,{headers:a(),credentials:"include"});if(!w.ok)throw new Error("Failed to fetch products");const h=await w.json();return{docs:h.docs||[],totalDocs:h.totalDocs||0,totalPages:h.totalPages||0,page:h.page||1,limit:h.limit||12}}catch(t){return console.error("Error fetching my bids products:",t),{docs:[],totalDocs:0,totalPages:0,page:1,limit:(e==null?void 0:e.limit)||12}}}async function F(e,t){try{const r=t||fetch,o=new Date().toISOString(),n=await r(`${i}/api/bridge/products?where[and][0][seller][equals]=${e}&where[and][1][status][equals]=available&where[and][2][active][equals]=true&where[and][3][auctionEndDate][greater_than]=${o}`,{headers:a(),credentials:"include"});if(!n.ok)throw new Error("Failed to fetch active products");return(await n.json()).docs||[]}catch(r){return console.error("Error fetching active products:",r),[]}}async function P(e,t){try{const o=await(t||fetch)(`${i}/api/bridge/products?where[and][0][seller][equals]=${e}&where[and][1][active][equals]=false`,{headers:a(),credentials:"include"});if(!o.ok)throw new Error("Failed to fetch hidden products");return(await o.json()).docs||[]}catch(r){return console.error("Error fetching hidden products:",r),[]}}async function k(e,t){try{const r=t||fetch,o=new Date().toISOString(),n=await r(`${i}/api/bridge/products?where[and][0][seller][equals]=${e}&where[and][1][or][0][status][equals]=sold&where[and][1][or][1][status][equals]=ended&where[and][1][or][2][and][0][status][equals]=available&where[and][1][or][2][and][1][auctionEndDate][less_than_equal]=${o}`,{headers:a(),credentials:"include"});if(!n.ok)throw new Error("Failed to fetch ended products");return(await n.json()).docs||[]}catch(r){return console.error("Error fetching ended products:",r),[]}}async function j(e,t){try{const o=await(t||fetch)(`${i}/api/bridge/products/${e}`,{headers:a(),credentials:"include"});if(!o.ok)throw new Error("Failed to fetch product");return await o.json()}catch(r){return console.error("Error fetching product:",r),null}}async function R(e){try{const t=await fetch(`${i}/api/bridge/products/${e}/status`,{headers:a(),credentials:"include"});if(!t.ok)throw new Error("Failed to check product status");return await t.json()}catch(t){return console.error("Error checking product status:",t),null}}async function T(e){try{const t=await fetch(`${i}/api/bridge/products`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify(e)});if(!t.ok){const o=await t.text();throw new Error(`Failed to create product: ${o}`)}const r=await t.json();return r.doc||r}catch(t){return console.error("Error creating product:",t),null}}async function O(e,t){try{const r=new AbortController,o=setTimeout(()=>r.abort(),3e4),n=await fetch(`${i}/api/bridge/products/${e}`,{method:"PATCH",headers:a(),credentials:"include",body:JSON.stringify(t),signal:r.signal});if(clearTimeout(o),!n.ok){const c=await n.text();throw new Error(`Failed to update product: ${n.status} - ${c}`)}const s=await n.json();return s.doc||s}catch(r){throw r instanceof Error&&r.name==="AbortError"?(console.error("Update timed out after 30 seconds"),new Error("Request timed out. The server might be processing your request.")):(console.error("Error updating product:",r),r)}}async function A(){try{return(await fetch(`${i}/api/bridge/users/logout`,{method:"POST",headers:a(),credentials:"include"})).ok}catch(e){return console.error("Error logging out:",e),!1}}async function f(e){try{const r=await(e||fetch)(`${i}/api/bridge/users/me`,{headers:a(),credentials:"include"});return r.ok&&(await r.json()).user||null}catch(t){return console.error("Error fetching current user:",t),null}}async function $(e,t){try{const o=await(t||fetch)(`${i}/api/bridge/bids?where[product][equals]=${e}&sort=-bidTime&limit=1000`,{headers:a(),credentials:"include"});if(!o.ok)throw new Error("Failed to fetch bids");return(await o.json()).docs||[]}catch(r){return console.error("Error fetching bids:",r),[]}}async function D(){try{const e=await fetch(`${i}/api/bridge/products?where[status][in][0]=sold&where[status][in][1]=ended&limit=100`,{headers:a(),credentials:"include"});if(!e.ok)throw new Error("Failed to fetch purchases");const r=(await e.json()).docs||[],o=await f();if(!o)return[];const n=[];for(const s of r){const c=await $(s.id);if(c.length>0){const d=c[0];(typeof d.bidder=="object"?d.bidder.id:d.bidder)===o.id&&n.push(s)}}return n}catch(e){return console.error("Error fetching purchases:",e),[]}}async function U(e,t,r){try{const o=await fetch(`${i}/api/bridge/messages`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({product:e,receiver:t,message:r})});if(!o.ok)throw new Error("Failed to send message");const n=await o.json();return n.doc||n}catch(o){return console.error("Error sending message:",o),null}}async function I(e,t,r){try{const o=r!=null&&r.latest?"-createdAt":"createdAt";let n=`${i}/api/bridge/messages?where[product][equals]=${e}&sort=${o}`;t&&(n+=`&where[createdAt][greater_than]=${t}`),r!=null&&r.before&&(n+=`&where[createdAt][less_than]=${r.before}`),r!=null&&r.limit&&(n+=`&limit=${r.limit}`);const s=await fetch(n,{headers:a(),credentials:"include"});if(!s.ok)throw new Error("Failed to fetch messages");const d=(await s.json()).docs||[];return r!=null&&r.latest?d.reverse():d}catch(o){return console.error("Error fetching messages:",o),[]}}async function B(e){try{const t=await fetch(`${i}/api/bridge/messages/${e}?depth=1`,{headers:a(),credentials:"include"});return t.ok?await t.json():null}catch(t){return console.error("Error fetching message:",t),null}}async function E(){try{const e=await fetch(`${i}/api/bridge/messages?limit=1000&sort=-createdAt`,{headers:a(),credentials:"include"});if(!e.ok)throw new Error("Failed to fetch conversations");const r=(await e.json()).docs||[],o=await f();if(!o)return[];const n=r.filter(c=>{const d=typeof c.sender=="object"?c.sender.id:c.sender,u=typeof c.receiver=="object"?c.receiver.id:c.receiver;return d===o.id||u===o.id}),s=new Map;for(const c of n){const d=typeof c.product=="object"?c.product:null;if(!d)continue;const u=d.id;s.has(u)||s.set(u,{product:d,lastMessage:c,unreadCount:0}),(typeof c.receiver=="object"?c.receiver.id:c.receiver)===o.id&&!c.read&&s.get(u).unreadCount++}return Array.from(s.values())}catch(e){return console.error("Error fetching conversations:",e),[]}}async function C(){try{return(await E()).reduce((t,r)=>t+r.unreadCount,0)}catch(e){return console.error("Error fetching unread message count:",e),0}}async function M(e,t){try{await fetch(`${i}/api/bridge/typing`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({product:e,isTyping:t})})}catch(r){console.error("Error setting typing status:",r)}}async function J(e){try{return(await fetch(`${i}/api/bridge/messages/${e}`,{method:"PATCH",headers:a(),credentials:"include",body:JSON.stringify({read:!0})})).ok}catch(t){return console.error("Error marking message as read:",t),!1}}async function N(e){try{return!!(await fetch(`${i}/api/bridge/media/${e}`,{method:"DELETE",headers:a(),credentials:"include"})).ok}catch(t){return console.error("Error deleting media:",t),!1}}async function x(e){var t;try{const r=new FormData;r.append("file",e);const o=y(),n={};o&&(n.Authorization=`JWT ${o}`);const s=await fetch(`${i}/api/bridge/media`,{method:"POST",headers:n,credentials:"include",body:r});if(!s.ok)return null;const c=await s.json();return((t=c.doc)==null?void 0:t.id)||c.id}catch(r){return console.error("Error uploading media:",r),null}}async function _(){try{const e=await fetch(`${i}/api/bridge/users/limits`,{headers:a(),credentials:"include"});if(!e.ok)throw new Error("Failed to fetch user limits");return await e.json()}catch(e){return console.error("Error fetching user limits:",e),null}}async function H(e,t,r){var o,n;try{const s=await fetch(`${i}/api/bridge/ratings`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({transaction:e,rating:t,comment:r})});if(!s.ok){const d=await s.json().catch(()=>null);throw new Error(((n=(o=d==null?void 0:d.errors)==null?void 0:o[0])==null?void 0:n.message)||"Failed to create rating")}const c=await s.json();return c.doc||c}catch(s){throw console.error("Error creating rating:",s),s}}async function L(e,t="received"){try{const r=await fetch(`${i}/api/bridge/users/${e}/ratings?type=${t}&depth=3`,{headers:a(),credentials:"include"});if(!r.ok)throw new Error("Failed to fetch user ratings");return(await r.json()).docs||[]}catch(r){return console.error("Error fetching user ratings:",r),[]}}function z(e){const t=e.filter(n=>n.raterRole==="buyer"),r=e.filter(n=>n.raterRole==="seller"),o=n=>n.length===0?0:n.reduce((c,d)=>c+d.rating,0)/n.length;return{averageRating:o(e),totalRatings:e.length,asSeller:{averageRating:o(t),totalRatings:t.length},asBuyer:{averageRating:o(r),totalRatings:r.length}}}async function G(e){try{const t=await fetch(`${i}/api/bridge/users/${e}`,{headers:a(),credentials:"include"});if(!t.ok)throw new Error("Failed to fetch user profile");return await t.json()}catch(t){return console.error("Error fetching user profile:",t),null}}async function V(e,t){try{const r=new URLSearchParams;t!=null&&t.status&&r.append("where[status][equals]",t.status),(t==null?void 0:t.active)!==void 0&&r.append("where[active][equals]",String(t.active)),t!=null&&t.limit&&r.append("limit",String(t.limit)),t!=null&&t.page&&r.append("page",String(t.page)),r.append("sort","-createdAt");const o=await fetch(`${i}/api/bridge/users/${e}/products?${r.toString()}`,{headers:a(),credentials:"include"});if(!o.ok)throw new Error("Failed to fetch user products");const n=await o.json();return{docs:n.docs||[],totalDocs:n.totalDocs||0,totalPages:n.totalPages||0}}catch(r){return console.error("Error fetching user products:",r),{docs:[],totalDocs:0,totalPages:0}}}async function W(e){var t;try{const r=await f();if(!r)return null;const o=await fetch(`${i}/api/bridge/ratings?where[transaction][equals]=${e}&where[rater][equals]=${r.id}&depth=1`,{headers:a(),credentials:"include"});if(!o.ok)throw new Error("Failed to fetch rating");return((t=(await o.json()).docs)==null?void 0:t[0])||null}catch(r){return console.error("Error fetching rating:",r),null}}async function Q(e){var t;try{const r=await fetch(`${i}/api/bridge/transactions?where[product][equals]=${e}&depth=1`,{headers:a(),credentials:"include"});if(!r.ok)throw new Error("Failed to fetch transaction");return((t=(await r.json()).docs)==null?void 0:t[0])||null}catch(r){return console.error("Error fetching transaction:",r),null}}async function K(e,t){try{const r=await fetch(`${i}/api/bridge/void-request/create`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({transactionId:e,reason:t})}),o=await r.json();return r.ok?{success:!0,voidRequest:o.voidRequest}:{success:!1,error:o.error||"Failed to create void request"}}catch(r){return console.error("Error creating void request:",r),{success:!1,error:"Failed to create void request"}}}async function X(e,t,r){try{const o=await fetch(`${i}/api/bridge/void-request/respond`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({voidRequestId:e,action:t,rejectionReason:r})}),n=await o.json();return o.ok?{success:!0,voidRequest:n.voidRequest,requiresSellerChoice:n.requiresSellerChoice}:{success:!1,error:n.error||"Failed to respond to void request"}}catch(o){return console.error("Error responding to void request:",o),{success:!1,error:"Failed to respond to void request"}}}async function Y(e,t){try{const r=await fetch(`${i}/api/bridge/void-request/seller-choice`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({voidRequestId:e,choice:t})}),o=await r.json();return r.ok?{success:!0,voidRequest:o.voidRequest,notifiedBidders:o.notifiedBidders}:{success:!1,error:o.error||"Failed to submit seller choice",onlyOption:o.onlyOption}}catch(r){return console.error("Error submitting seller choice:",r),{success:!1,error:"Failed to submit seller choice"}}}async function Z(e,t){try{const r=await fetch(`${i}/api/bridge/void-request/second-bidder-response`,{method:"POST",headers:a(),credentials:"include",body:JSON.stringify({voidRequestId:e,action:t})}),o=await r.json();return r.ok?{success:!0,voidRequest:o.voidRequest}:{success:!1,error:o.error||"Failed to respond to offer"}}catch(r){return console.error("Error responding to second bidder offer:",r),{success:!1,error:"Failed to respond to offer"}}}export{x as A,O as B,T as C,R as D,C as E,A as F,S as G,q as H,f as a,P as b,k as c,D as d,G as e,F as f,_ as g,V as h,L as i,z as j,B as k,E as l,J as m,j as n,I as o,$ as p,Q as q,W as r,M as s,H as t,K as u,X as v,Y as w,Z as x,U as y,N as z};
